<!DOCTYPE html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
</head>
<title>NEXT - Random Intelligence Test</title>
<style>
html, body {
background-color: rgba(16, 16, 32, 1.0);
color:#FFFFFF;
font-size:16px;
width:  100%;
height: 100%;
}
a:link, a:visited {
  color: #0DD;
  text-align: center;
  text-decoration: none;
  display: inline-block;
}
.f16 {font-size: 16pt; color:  #0C0;}
.F16 {font-size: 16pt; color:  #0DD;}
</style> 
<body>
<table width=100% heigth=100%>
<tbody>
<tr>
<td width=15%>&nbsp;</td>
<td width=70%>
<p align=left class=f16><br><br><br>
The FIRST.html creates cookies that NEXT.html uses and updates.<br> 
To input the TB table from the AI, you need to reload this page.<br>Script checks TB and if there are any errors that the AI needed, alerts them. After getting new TB you can again reload this page for input.<br>If the errors are absent then:<br>
if the script can't find generated by the AI the line(s) of five or more the same marked chips, it adds 1 to the moves number and prints "ok" message for the AI,<br>
else script updates TB and generates five new random chips, all this for presenting to the AI or prints "F" message for the AI. 
</p>
</p><p align=left class=F16> 
<br></p>
<p align=left class=F16 id="OUT"></p>
<p align=left class=F16><span id="NEXT5"></span></p>
<p align=left class=f16>
<a href="https://github.com/ogrnv/random-intelligence-tests" target="_blank">https://github.com/ogrnv/random-intelligence-tests</a>
<br><br>
</p>
<script>

var hm=0,	//size of a side of square table/board.
kcb=0,		//how many of types of chips are placed on the table	
emb=0,		//number of empty sells 22=64-42
mn=0,		//moves number
qn=0,		//number of finished lines >4 chips long
stp=0,		//steps
osh=0,
xx="",
s="",
inpr="",
ina, jna, iko, jko, ox5=0, hmb, bc;
var  n5x, n5 = [];
var Csa = [], Csb = [], TC = [],
	x0 = -1, x1 = -1, y0 = -1, y2 = -1; //0-start address 1-finish one
function random(min, max) {
var mi = Math.ceil(min), ma = Math.floor(max);
return Math.floor(Math.random()*(ma-mi+1)+mi);
}
/*function random(min, max) {//https://stackoverflow.com/a/65440696
    const range = max - min + 1
    const bytes_needed = Math.ceil(Math.log2(range) / 8)
    const cutoff = Math.floor((256 ** bytes_needed) / range) * range
    const bytes = new Uint8Array(bytes_needed)
    let value
    do {
        crypto.getRandomValues(bytes)
        value = bytes.reduce((acc, x, n) => acc + x * 256 ** n, 0)
    } while (value >= cutoff)
    return min + value % range
}*/
function fz(fzx, fzy){
 if((fzx>0)&&(Csa[fzx-1][fzy]==0)&&(TC[fzx-1][fzy]==0))
   {TC[fzx-1][fzy]=1; fz((fzx-1),fzy);}
 if((fzx<hm-1)&&(Csa[fzx+1][fzy]==0)&&(TC[fzx+1][fzy]==0))
   {TC[fzx+1][fzy]=1; fz((fzx+1),fzy);}
 if((fzy>0)&&(Csa[fzx][fzy-1]==0)&&(TC[fzx][fzy-1]==0))
   {TC[fzx][fzy-1]=1; fz(fzx,(fzy-1));}
 if((fzy<hm-1)&&(Csa[fzx][fzy+1]==0)&&(TC[fzx][fzy+1]==0))
   {TC[fzx][fzy+1]=1; fz(fzx,(fzy+1));}
}
function hor(colr, i, j){
ina=i; jna=j;
while((ina-1) >= 0){
ina--;
if(colr != Csb[ina][j]){ina++; break;}	
}
// ищем справа первый другой цвет
iko=i;
while((iko+1) < hm){
iko++;
if(colr != Csb[iko][j]){iko--; break;}	
}
hmb=iko-ina+1; // длина линии по горизонтали
if (hmb>4) {ox5=1;}
//hor end
}
//-----------------------------------------
function ver(colr, i, j){
//v по вертикали (меняем второй индекс таблицы, i=const)
// ищем сверху первый другой цвет
jna=j; ina=i;
while((jna-1) >= 0){
jna--;
if(colr != Csb[i][jna]){jna++; break;}	
}
// ищем вниз первый другой цвет
jko=j;
while((jko+1) < hm){
jko++;
if(colr != Csb[i][jko]){jko--; break;}	
}
hmb=jko-jna+1; // длина линии
if (hmb>4) {ox5=1;}
// ver ends
}
//-----------------------------------------
function nak(colr, i, j){
//наклонно '\' - меняютя i j
ina=i; jna=j;
while((ina-1) >= 0 && (jna-1) >= 0){
ina--; jna--;
if(colr != Csb[ina][jna]){ina++; jna++; break;}	
}
iko=i; jko=j;
while((iko+1) < hm && (jko+1) < hm){
iko++; jko++;
if(colr != Csb[iko][jko]){iko--; jko--; break;}	
}
hmb=jko-jna+1; // длина линии
if (hmb>4) {ox5=1;}
// '/' ends
}
//-----------------------------------------
function nkl(colr, i, j){
//наклонно '/' - меняютя i j
ina=i; jna=j;
while((ina+1) < hm && (jna-1) >= 0){
ina++; jna--;
if(colr != Csb[ina][jna]){ina--; jna++; break;}	
}

iko=i; jko=j;
while((iko-1) >= 0 && (jko+1) < hm){
iko--; jko++;
if(colr != Csb[iko][jko]){iko++; jko--; break;}	
}
hmb=ina-iko+1; // длина линии
if (hmb>4) {ox5=1;}
// '\' ends
}
function ValuX(colr, i, j)
{
let b, e, n, an = new Int32Array(1);
let tt = [];// таблица типов

// выбираем случайно тип {0,1..3} и проверяем его на линию > 4 фишек
for (e = 0; e < 4; e++) tt[e] = -1; //номер строки = типу, значение > 0 номер по порядку
 e=0;
//найти порядок 4х типов 
while (e<4){ // найти следующий тип - | / \  для исследования на >4
	window.crypto.getRandomValues(an); n=0;	
	while(n<16){
	b = 3 & an[0]; //выделяем 2 бита справа
	if (tt[b]  == -1) {tt[b]  = e;
	e++; if (e==4) break;}
	an[0] = an[0] >>> 2; // сдвигаем на 2 бита вправо
	n++; 
	}
}
//пытаемся найти линию в порядке определенном в tt
for (e=0; e<4; e++){ // e - номер порядка (по порядку становись)
b=1;
n=0;
while(n<4){ //ищем номер порядка e
	if(tt[n]==e) {//n - номер типа - | / \ 
	//для определенного типа n ищем 5 в ряд 
	switch (n) {
  	case 0: hor(colr, i, j); break;
	case 1: ver(colr, i, j); break;
	case 2: nak(colr, i, j); break;
	case 3: nkl(colr, i, j); break; 
	default:
	}
	}
	if(ox5>0) {
	if(hmb>4){// сколько вариантов удаления от точки с мин знач. х
		if(hmb==5){bc=0;}
		else{
		bc=random(0, hmb - 5); //смещение от точки с мин знач. х
		}
	// delete 5 then add 5
	// убираем фишки
	for(b=0; b<5; b++){
	// обнулить 5 cells
	if(n==0){Csb[ina+bc+b][jna]=0;}
	if(n==1){Csb[ina][jna+bc+b]=0;}
	if(n==2){Csb[ina+bc+b][jna+bc+b]=0;}
	if(n==3){Csb[ina-bc-b][jna+bc+b]=0;}
	}
var hmze=0, fri = [-1,-1,-1,-1,-1], frj = [-1,-1,-1,-1,-1];
for (i = 0; i < hm; i += 1){
	for (j = 0; j < hm; j += 1){
		if(Csb[i][j] == 0) { fri[hmze]=i; frj[hmze]=j; hmze++;}
	}
}
// добавить пять фишек
for (i = 0; i < 5; i++){
		bc=random(0, hmze - 1); //какую именно взять
		var ic, jc;
		ic=fri[bc]; jc=frj[bc];
		Csb[ic][jc]=Number(n5x.substring(i, i+1));
//изменить таблицу св.клеток last--> на место bc и hmze--
		fri[bc]=fri[hmze-1]; frj[bc]=frj[hmze-1]; hmze = hmze - 1;
}
		} //if(hmb>4
		n=4; // найдено > 4
	}
	else n++;
}
if(ox5==1) e=4;
}
}//ValuX end

function viv(){
xx = xx + "<br><b> Moves = " + mn + " Steps = " +qn+ "</b> <br>The last good TB:<br>";
for (i=0; i<hm; i++) {xx=xx+Csa[i]+"<br>";}
document.getElementById("OUT").innerHTML = xx;
exit();
}
let inp=""; inp=prompt("Input TB:", "");
if (inp !== null) {inpr = inp.replace(/[^0-9]/g, "");
	}
else {alert("You canceled the input"); exit();}
document.cookie = "tb="+inpr;
//let xx = document.cookie;
let csx="";
let tbx="";
const hmc = document.cookie.split(';')
for (let i = 0; i < hmc.length; i++) {
	let c = hmc[i].trim().split('=')
	let str=decodeURIComponent(c[1]);	
	switch(c[0]) {
	case "hm": hm=Number(str); break;	
	case "kcb": kcb=Number(str); break;	
	case "emb": emb=Number(str); break;
	case "mn": mn=Number(str); break;
	case "qn": qn=Number(str); break;
	case "stp": stp=Number(str); break;	
	case "cs": csx=str; break;
	case "tb": tbx=str; break;
	case "n5": n5x=str; break;
	default:
	} 
}
if(tbx.length != hm*hm) {alert("b - TB size is not "+hm+"*"+hm); exit();}
let m=0, ca, cb,
	cbz=0, // zeroes number
	cab=0; //the marking of moving chip 
n=0; let err=0;
for (i = 0; i < hm; i++){
	if(n<5){n5[n]=Number(n5x.substring(n, n+1));}
	Csa[i] = []; Csb[i] = []; TC[i] = [];
	for (j = 0; j < hm; j++){
		TC[i][j] = 0;
		Csa[i][j] = ca = Number(csx.substring(n, n+1)); //before
		Csb[i][j] = cb = Number(tbx.substring(n, n+1)); //after
		if(cb==0) cbz++;
		if(ca!=cb) {
		 // one of them should be zero
		 if(ca>0&&cb>0) {err=1;}
		 if(ca>0) {x0=i; y0=j; m++; //0-start address
		 }
		 if(cb>0) {x1=i; y1=j; m++; //1-finish address
		 }		 
		}
		n++;
	}
}
if(err==1) {xx="b - some chips have been swapped or relabeled";  viv();}
if(cbz!=emb) {xx="b - the TB zeros number has been changed";  viv();}
if(m<2) {xx="b - TB has less than two changes";  viv();}
if(m>2) {xx="b - TB has more than two changes"; viv();}
//x0=i; y0=j SA
if(Csa[x0][y0]!=Csb[x1][y1]) {xx="b - the relocated chip's markings have been changed";
 viv();}
//check accessibility FA from SA
fz(x0,y0);
if(TC[x1][y1]==0){
 xx="b - there is no a path from SA to FA"; viv();}
ValuX(Csb[x1][y1],x1,y1);
mn++;
document.cookie = "mn=" + mn;
if(ox5>0){qn++; document.cookie = "qn=" + qn;}
let sc=""; sc=Csb; cs=sc.toString().replace(/[^0-9]/g, "");
document.cookie = "cs="+cs;
xx = "<b> Moves = " + mn + " Steps = " +qn+ "</b> <br>";
if(ox5==0) xx=xx+"ok - go to the next move<br><br>";
else {
	if(qn<stp) {
		n=0;
		while(n<5){n5[n]=random(1, kcb);n++;}
		s=n5;
		document.cookie = "n5="+s.toString().replace(/[^0-9]/g, "");
		s = "The next five chips: "; for (i=0; i<4; i++) s=s+n5[i]+","; s=s+n5[4];
		document.getElementById("NEXT5").innerHTML = s;
		xx=xx+"s - the updated board:<br>";}
	else {xx=xx+"F - the game is over. Thanks!";}
}
if(qn<stp){
for (i=0; i<hm; i++) xx=xx+Csb[i]+"<br>";
}
document.getElementById("OUT").innerHTML = xx;
</script>
</td><td width=15%>&nbsp;</td></tr></tbody>
</table>
</body>
</html>
