<!DOCTYPE html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
</head>
<title>NEXTSAFA - Random Intelligence Test</title>
<!--
NEXTSAFA uses only SA FA values gotten from AI. It is useful when AI makes wrong desks.
-->
<style>
html, body {
background-color: rgba(16, 16, 32, 1.0);
color:#FFFFFF;
font-size:16px;
width:  100%;
height: 100%;
}
a:link, a:visited {
  color: #0DD;
  text-align: center;
  text-decoration: none;
  display: inline-block;
}
.f16 {font-size: 16pt; color:  #0C0;}
.F16 {font-size: 16pt; color:  #0DD;}
</style> 
<body>
<table width=100% heigth=100%>
<tbody>
<tr>
<td width=15%>&nbsp;</td>
<td width=70%>
<p align=left class=F16><br></p>

<p align=left class=F16 id="OUT"></p>
<p align=left class=F16 id="NEXT5"></p>
<div style="display:inline-block; vertical-align:top;">
  <button class="js-copy-btn"><span id="ISS">Copy to clipboard</span></button><br />
</div>
<div style="display:inline-block;">
  <textarea class="js-test-textarea" style="display:none;" cols="35" rows="4">
  </textarea>
</div>
<p align=left class=f16><br><br>
NEXTSAFA uses only SA FA values gotten from AI. It is useful when AI makes wrong desks.<br>
The FIRST-NB.html or INPUT-NB.html creates cookies that NEXTSAFA.html uses and updates.<br> 
To input the SA, FA from the AI, you need to reload this page.<br>The script checks the SA, FA and prints messages for AI. After getting new SA, FA you can again reload this page for input.<br>If the errors are absent then:<br>
if the script can't find generated by the AI the line(s) of five or more the same marked chips, it adds 1 to the moves number and prints "ok" message for the AI,<br>
else script updates TB and generates, if needed, five new random chips, all this for presenting to the AI or prints "F" message for the AI. 
</p>
</td><td width=15%>&nbsp;</td></tr></tbody>
</table>
<script>
//<span id="NEXT5">*</span>
var hm=0,	//size of a side of square table/board.
kcb=0,		//how many of types of chips are placed on the table	
emb=0,		//number of empty sells 22=64-42
mn=0,		//moves number
qn=0,		//number of finished lines >4 chips long
stp=0,		//steps
osh=0,
xx="", xxx="", s="", inpr="",
ina, jna, iko, jko, ox5=0, hmb, bc, csx="", tbx="";
var  n5x, n5 = [];
var Csa = [], Csb = [], TC = [],
	x0 = -1, x1 = -1, y0 = -1, y2 = -1; //0-start address 1-finish one
/*function random(min, max) {
var mi = Math.ceil(min), ma = Math.floor(max);
return Math.floor(Math.random()*(ma-mi+1)+mi);
}*/
function subs(strx, find, replace){
	var escapedFind=find.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1");
    return strx.replace(new RegExp(escapedFind, 'g'), replace);
}
function copyTextToClipboard(text) {
  var tA = document.createElement("textarea");
  tA.style.position = 'fixed';
  tA.style.top = 0;
  tA.style.left = 0;
  // Ensure it has a small width and height. Setting to 1px / 1em
  // doesn't work as this gives a negative w/h on some browsers.
  tA.style.width = '2em';
  tA.style.height = '2em';
  // We don't need padding, reducing the size if it does flash render.
  tA.style.padding = 0;
  // Clean up any borders.
  tA.style.border = 'none';
  tA.style.outline = 'none';
  tA.style.boxShadow = 'none';
  // Avoid flash of the white box if rendered for any reason.
  tA.style.background = 'transparent';
  tA.value = text;
  document.body.appendChild(tA);
  tA.focus();
  tA.select();
  try {
    var successful = document.execCommand('copy');
//    var msg = successful ? 'successful' : 'unsuccessful';
//    console.log('Copying text command was ' + msg);
  } 
  catch (err) {
    alert('Oops, unable to copy');
  }
  document.getElementById("ISS").innerHTML = "Copied";
  document.body.removeChild(tA);
}
var copyBtn = document.querySelector('.js-copy-btn');
copyBtn.addEventListener('click', function(event) {
  copyTextToClipboard(xxx);
});

function random(min, max) {//https://stackoverflow.com/a/65440696
    const range = max - min + 1
    const bytes_needed = Math.ceil(Math.log2(range) / 8)
    const cutoff = Math.floor((256 ** bytes_needed) / range) * range
    const bytes = new Uint8Array(bytes_needed)
    let value
    do {
        crypto.getRandomValues(bytes)
        value = bytes.reduce((acc, x, n) => acc + x * 256 ** n, 0)
    } while (value >= cutoff)
    return min + value % range
}
function fz(fzx, fzy){
 if((fzx>0)&&(Csa[fzx-1][fzy]==0)&&(TC[fzx-1][fzy]==0))
   {TC[fzx-1][fzy]=1; fz((fzx-1),fzy);}
 if((fzx<hm-1)&&(Csa[fzx+1][fzy]==0)&&(TC[fzx+1][fzy]==0))
   {TC[fzx+1][fzy]=1; fz((fzx+1),fzy);}
 if((fzy>0)&&(Csa[fzx][fzy-1]==0)&&(TC[fzx][fzy-1]==0))
   {TC[fzx][fzy-1]=1; fz(fzx,(fzy-1));}
 if((fzy<hm-1)&&(Csa[fzx][fzy+1]==0)&&(TC[fzx][fzy+1]==0))
   {TC[fzx][fzy+1]=1; fz(fzx,(fzy+1));}
}
function ver(colr, i, j){
ina=i; jna=j;
while((ina-1) >= 0){
ina--;
if(colr != Csb[ina][j]){ina++; break;}	
}
iko=i;
while((iko+1) < hm){
iko++;
if(colr != Csb[iko][j]){iko--; break;}	
}
hmb=iko-ina+1;
if (hmb>4) {ox5=1;}
}
//-----------------------------------------
function hor(colr, i, j){
jna=j; ina=i;
while((jna-1) >= 0){
jna--;
if(colr != Csb[i][jna]){jna++; break;}	
}
jko=j;
while((jko+1) < hm){
jko++;
if(colr != Csb[i][jko]){jko--; break;}	
}
hmb=jko-jna+1;
if (hmb>4) {ox5=1;}
}
//-----------------------------------------
function nak(colr, i, j){
ina=i; jna=j;
while((ina-1) >= 0 && (jna-1) >= 0){
ina--; jna--;
if(colr != Csb[ina][jna]){ina++; jna++; break;}	
}
iko=i; jko=j;
while((iko+1) < hm && (jko+1) < hm){
iko++; jko++;
if(colr != Csb[iko][jko]){iko--; jko--; break;}	
}
hmb=jko-jna+1;
if (hmb>4) {ox5=1;}
}
//-----------------------------------------
function nkl(colr, i, j){
ina=i; jna=j;
while((ina+1) < hm && (jna-1) >= 0){
ina++; jna--;
if(colr != Csb[ina][jna]){ina--; jna++; break;}	
}
iko=i; jko=j;
while((iko-1) >= 0 && (jko+1) < hm){
iko--; jko++;
if(colr != Csb[iko][jko]){iko++; jko--; break;}	
}
hmb=ina-iko+1;
if (hmb>4) {ox5=1;}
}
function ValuX(colr, i, j)
{
let b, e, n, an = new Int32Array(1);
let tt = [];// таблица типов

// выбираем случайно тип {0,1..3} и проверяем его на линию > 4 фишек
for (e = 0; e < 4; e++) tt[e] = -1; //номер строки = типу, значение > 0 номер по порядку
 e=0;
//найти порядок 4х типов 
while (e<4){ // найти следующий тип - | / \  для исследования на >4
	window.crypto.getRandomValues(an); n=0;	
	while(n<16){
	b = 3 & an[0]; //выделяем 2 бита справа
	if (tt[b]  == -1) {tt[b]  = e;
	e++; if (e==4) break;}
	an[0] = an[0] >>> 2; // сдвигаем на 2 бита вправо
	n++; 
	}
}
//пытаемся найти линию в порядке определенном в tt
for (e=0; e<4; e++){ // e - номер порядка (по порядку становись)
b=1;
n=0;
while(n<4){ //ищем номер порядка e
	if(tt[n]==e) {//n - номер типа - | / \ 
	//для определенного типа n ищем 5 в ряд 
	switch (n) {
  	case 0: ver(colr, i, j); break;
	case 1: hor(colr, i, j); break;
	case 2: nak(colr, i, j); break;
	case 3: nkl(colr, i, j); break; 
	default:
	}
	}
	if(ox5>0) {
	if(hmb>4){// сколько вариантов удаления от точки с мин знач. х
		if(hmb==5){bc=0;}
		else{
		bc=random(0, hmb - 5); //смещение от точки с мин знач. х
		}
	// delete 5 then add 5
	// убираем фишки
	for(b=0; b<5; b++){
	// обнулить 5 cells
	if(n==0){Csb[ina+bc+b][jna]=0;}
	if(n==1){Csb[ina][jna+bc+b]=0;}
	if(n==2){Csb[ina+bc+b][jna+bc+b]=0;}
	if(n==3){Csb[ina-bc-b][jna+bc+b]=0;}
	}
var hmze=0, fri = [-1,-1,-1,-1,-1], frj = [-1,-1,-1,-1,-1];
for (i = 0; i < hm; i += 1){
	for (j = 0; j < hm; j += 1){
		if(Csb[i][j] == 0) { fri[hmze]=i; frj[hmze]=j; hmze++;}
	}
}
// добавить пять фишек
for (i = 0; i < 5; i++){
		bc=random(0, hmze - 1); //какую именно взять
		var ic, jc;
		ic=fri[bc]; jc=frj[bc];
		Csb[ic][jc]=Number(n5x.substring(i, i+1));
//изменить таблицу св.клеток last--> на место bc и hmze--
		fri[bc]=fri[hmze-1]; frj[bc]=frj[hmze-1]; hmze = hmze - 1;
}
		} //if(hmb>4
		n=4; // найдено > 4
	}
	else n++;
}
if(ox5==1) e=4;
}
}//ValuX end

function viv(){
xx = xx + "<br><b>Moves = " + mn + " Steps = " +qn+ "</b> <br>The last good TB:<br>";
for (i=0; i<hm; i++) {xx=xx+Csa[i]+"<br>";}
xxx=xx;
xxx=subs(xxx, "<b>", ""); xxx=subs(xxx, "</b>", "");xxx=subs(xxx, "<br>", "\n");
document.getElementById("OUT").innerHTML = xx;
exit;
}
String.prototype.replaceAt = function(ix, rt) {
  return this.substr(0, ix) + rt + this.substr(ix + rt.length);
}
let inp=""; inp=prompt("Input SA and FA:", "");
if (inp == null) {alert("You canceled the input"); exit;}

const hmc = document.cookie.split(';')
for (let i = 0; i < hmc.length; i++) {
	let c = hmc[i].trim().split('=')
	let str=decodeURIComponent(c[1]);	
	switch(c[0]) {
	case "hm": hm=Number(str); break;	
	case "kcb": kcb=Number(str); break;	
	case "emb": emb=Number(str); break;
	case "mn": mn=Number(str); break;
	case "qn": qn=Number(str); break;
	case "stp": stp=Number(str); break;	
	case "cs": tbx=csx=str; break;
	case "tb": break;
	case "n5": n5x=str; break;
	default:
	} 
}
n=0;
for (i = 0; i < hm; i++){
	Csa[i] = [];
	for (j = 0; j < hm; j++){
		Csa[i][j] = Number(csx.substring(n, n+1));
		n++;
	}
}
let u=0, si, inc=""; i=0;
while(i<100){
	si=inp.substring(i, i+1); 
	if (si=="["||si=="]"){u++;}
	if (si=="]"&&u==2){inc=inc+","}
	if((u==1||u==3)&&si!="[")inc=inc+si;
	if(si=="]"&&u==4) break;
	i++;	
}
if(u<4) {xx="Incorrect input. Check []"; viv();}
let dr=[-1,-1,-1,-1];
dr=inc.split(',')
i1=Number(dr[0]);j1=Number(dr[1]);i2=Number(dr[2]);j2=Number(dr[3]);
if(isNaN(i1)||isNaN(i2)||isNaN(j1)||isNaN(j2)||dr[0]==""||dr[1]==""||dr[2]==""||dr[3]==""){
	xx="Incorrect input. Not a number after comma or ["; viv();
}
if(i1 >= hm || i2 >= hm || j1 >= hm || j2 >= hm
|| i1<0 || i2<0 || j1<0 || j2<0){
xx="b - address(es) is(are) outside the board or negative"; viv();
}
// making swap
let n1=i1*hm+j1;
let n2=i2*hm+j2;
let sim1=tbx.substring(n1, n1+1);
let sim2=tbx.substring(n2, n2+1);

tbx=tbx.replaceAt(n1, sim2);
tbx=tbx.replaceAt(n2, sim1);
document.cookie = "tb="+tbx;

let m=0, ca, cb,
	cbz=0, // zeroes number
	cab=0; //the marking of moving chip 
n=0; let err=0, ir=[], jr=[];
for (i = 0; i < hm; i++){
	if(n<5){n5[n]=Number(n5x.substring(n, n+1));}
	Csb[i] = []; TC[i] = [];
	for (j = 0; j < hm; j++){
		TC[i][j] = 0;
		ca = Csa[i][j]; //before
		Csb[i][j] = cb = Number(tbx.substring(n, n+1)); //after
		if(cb==0) cbz++;
		if(ca!=cb) {
		 // one of them should be zero
		 if(ca>0&&cb>0) {ir[err]=i; jr[err]=j;err++;}
		 if(ca>0) {x0=i; y0=j; m++; //0-start address
		 }
		 if(cb>0) {x1=i; y1=j; m++; //1-finish address
		 }		 
		}
		n++;
	}
}
if(err>0||m<2) {
  xx="b - your SA and FA point to both<br>non-zero or both zero cells"; viv();
}
//check accessibility FA from SA
fz(x0,y0);
if(TC[x1][y1]==0){
 xx="b - there is no a path from SA to FA"; viv();}
ValuX(Csb[x1][y1],x1,y1);
mn++;
document.cookie = "mn=" + mn;
if(ox5>0){qn++; document.cookie = "qn=" + qn;}
let sc=""; sc=Csb; cs=sc.toString().replace(/[^0-9]/g, "");
document.cookie = "cs="+cs;
xx = "<b>Moves = " + mn + " Steps = " +qn+ "</b> <br>";
if(ox5==0) {xx=xx+"ok - your move is counted.<br>Verified board is:<br>";}
else {
	if(qn<stp) {
		n=0;
		while(n<5){n5[n]=random(1, kcb);n++;}
		s=n5;
		document.cookie = "n5="+s.toString().replace(/[^0-9]/g, "");
		s = "The next five chips: "; for (i=0; i<4; i++) s=s+n5[i]+","; s=s+n5[4];
		if(qn==(stp - 1)) s="";
		 document.getElementById("NEXT5").innerHTML = s;
		xx=xx+"s - the updated board:<br>";
	}
	else {xx=xx+"F - the game is over. Many thanks!";}
}

if(qn<stp){
for (i=0; i<hm; i++) xx=xx+Csb[i]+"<br>";
}
xxx=xx+s;
xxx=subs(xxx, "<b>", ""); xxx=subs(xxx, "</b>", "");xxx=subs(xxx, "<br>", "\n");
document.getElementById("OUT").innerHTML = xx;
</script>
</body>
</html>
